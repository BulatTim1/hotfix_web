{"ast":null,"code":"/*!\n * accounting.js v0.4.1\n * Copyright 2014 Open Exchange Rates\n *\n * Freely distributable under the MIT license.\n * Portions of accounting.js are inspired or borrowed from underscore.js\n *\n * Full details and documentation:\n * http://openexchangerates.github.io/accounting.js/\n */\n(function (root, undefined) {\n  /* --- Setup --- */\n  // Create the local library object, to be exported or referenced globally later\n  var lib = {}; // Current version\n\n  lib.version = '0.4.1';\n  /* --- Exposed settings --- */\n  // The library's settings configuration object. Contains default parameters for\n  // currency and number formatting\n\n  lib.settings = {\n    currency: {\n      symbol: \"$\",\n      // default currency symbol is '$'\n      format: \"%s%v\",\n      // controls output: %s = symbol, %v = value (can be object, see docs)\n      decimal: \".\",\n      // decimal point separator\n      thousand: \",\",\n      // thousands separator\n      precision: 2,\n      // decimal places\n      grouping: 3 // digit grouping (not implemented yet)\n\n    },\n    number: {\n      precision: 0,\n      // default precision on numbers is 0\n      grouping: 3,\n      // digit grouping (not implemented yet)\n      thousand: \",\",\n      decimal: \".\"\n    }\n  };\n  /* --- Internal Helper Methods --- */\n  // Store reference to possibly-available ECMAScript 5 methods for later\n\n  var nativeMap = Array.prototype.map,\n      nativeIsArray = Array.isArray,\n      toString = Object.prototype.toString;\n  /**\n   * Tests whether supplied parameter is a string\n   * from underscore.js\n   */\n\n  function isString(obj) {\n    return !!(obj === '' || obj && obj.charCodeAt && obj.substr);\n  }\n  /**\n   * Tests whether supplied parameter is a string\n   * from underscore.js, delegates to ECMA5's native Array.isArray\n   */\n\n\n  function isArray(obj) {\n    return nativeIsArray ? nativeIsArray(obj) : toString.call(obj) === '[object Array]';\n  }\n  /**\n   * Tests whether supplied parameter is a true object\n   */\n\n\n  function isObject(obj) {\n    return obj && toString.call(obj) === '[object Object]';\n  }\n  /**\n   * Extends an object with a defaults object, similar to underscore's _.defaults\n   *\n   * Used for abstracting parameter handling from API methods\n   */\n\n\n  function defaults(object, defs) {\n    var key;\n    object = object || {};\n    defs = defs || {}; // Iterate over object non-prototype properties:\n\n    for (key in defs) {\n      if (defs.hasOwnProperty(key)) {\n        // Replace values with defaults only if undefined (allow empty/zero values):\n        if (object[key] == null) object[key] = defs[key];\n      }\n    }\n\n    return object;\n  }\n  /**\n   * Implementation of `Array.map()` for iteration loops\n   *\n   * Returns a new Array as a result of calling `iterator` on each array value.\n   * Defers to native Array.map if available\n   */\n\n\n  function map(obj, iterator, context) {\n    var results = [],\n        i,\n        j;\n    if (!obj) return results; // Use native .map method if it exists:\n\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context); // Fallback for native .map:\n\n    for (i = 0, j = obj.length; i < j; i++) {\n      results[i] = iterator.call(context, obj[i], i, obj);\n    }\n\n    return results;\n  }\n  /**\n   * Check and normalise the value of precision (must be positive integer)\n   */\n\n\n  function checkPrecision(val, base) {\n    val = Math.round(Math.abs(val));\n    return isNaN(val) ? base : val;\n  }\n  /**\n   * Parses a format string or object and returns format obj for use in rendering\n   *\n   * `format` is either a string with the default (positive) format, or object\n   * containing `pos` (required), `neg` and `zero` values (or a function returning\n   * either a string or object)\n   *\n   * Either string or format.pos must contain \"%v\" (value) to be valid\n   */\n\n\n  function checkCurrencyFormat(format) {\n    var defaults = lib.settings.currency.format; // Allow function as format parameter (should return string or object):\n\n    if (typeof format === \"function\") format = format(); // Format can be a string, in which case `value` (\"%v\") must be present:\n\n    if (isString(format) && format.match(\"%v\")) {\n      // Create and return positive, negative and zero formats:\n      return {\n        pos: format,\n        neg: format.replace(\"-\", \"\").replace(\"%v\", \"-%v\"),\n        zero: format\n      }; // If no format, or object is missing valid positive value, use defaults:\n    } else if (!format || !format.pos || !format.pos.match(\"%v\")) {\n      // If defaults is a string, casts it to an object for faster checking next time:\n      return !isString(defaults) ? defaults : lib.settings.currency.format = {\n        pos: defaults,\n        neg: defaults.replace(\"%v\", \"-%v\"),\n        zero: defaults\n      };\n    } // Otherwise, assume format was fine:\n\n\n    return format;\n  }\n  /* --- API Methods --- */\n\n  /**\n   * Takes a string/array of strings, removes all formatting/cruft and returns the raw float value\n   * Alias: `accounting.parse(string)`\n   *\n   * Decimal must be included in the regular expression to match floats (defaults to\n   * accounting.settings.number.decimal), so if the number uses a non-standard decimal \n   * separator, provide it as the second argument.\n   *\n   * Also matches bracketed negatives (eg. \"$ (1.99)\" => -1.99)\n   *\n   * Doesn't throw any errors (`NaN`s become 0) but this may change in future\n   */\n\n\n  var unformat = lib.unformat = lib.parse = function (value, decimal) {\n    // Recursively unformat arrays:\n    if (isArray(value)) {\n      return map(value, function (val) {\n        return unformat(val, decimal);\n      });\n    } // Fails silently (need decent errors):\n\n\n    value = value || 0; // Return the value as-is if it's already a number:\n\n    if (typeof value === \"number\") return value; // Default decimal point comes from settings, but could be set to eg. \",\" in opts:\n\n    decimal = decimal || lib.settings.number.decimal; // Build regex to strip out everything except digits, decimal point and minus sign:\n\n    var regex = new RegExp(\"[^0-9-\" + decimal + \"]\", [\"g\"]),\n        unformatted = parseFloat((\"\" + value).replace(/\\((.*)\\)/, \"-$1\") // replace bracketed values with negatives\n    .replace(regex, '') // strip out any cruft\n    .replace(decimal, '.') // make sure decimal point is standard\n    ); // This will fail silently which may cause trouble, let's wait and see:\n\n    return !isNaN(unformatted) ? unformatted : 0;\n  };\n  /**\n   * Implementation of toFixed() that treats floats more like decimals\n   *\n   * Fixes binary rounding issues (eg. (0.615).toFixed(2) === \"0.61\") that present\n   * problems for accounting- and finance-related software.\n   */\n\n\n  var toFixed = lib.toFixed = function (value, precision) {\n    precision = checkPrecision(precision, lib.settings.number.precision);\n    var power = Math.pow(10, precision); // Multiply up by precision, round accurately, then divide and use native toFixed():\n\n    return (Math.round(lib.unformat(value) * power) / power).toFixed(precision);\n  };\n  /**\n   * Format a number, with comma-separated thousands and custom precision/decimal places\n   * Alias: `accounting.format()`\n   *\n   * Localise by overriding the precision and thousand / decimal separators\n   * 2nd parameter `precision` can be an object matching `settings.number`\n   */\n\n\n  var formatNumber = lib.formatNumber = lib.format = function (number, precision, thousand, decimal) {\n    // Resursively format arrays:\n    if (isArray(number)) {\n      return map(number, function (val) {\n        return formatNumber(val, precision, thousand, decimal);\n      });\n    } // Clean up number:\n\n\n    number = unformat(number); // Build options object from second param (if object) or all params, extending defaults:\n\n    var opts = defaults(isObject(precision) ? precision : {\n      precision: precision,\n      thousand: thousand,\n      decimal: decimal\n    }, lib.settings.number),\n        // Clean up precision\n    usePrecision = checkPrecision(opts.precision),\n        // Do some calc:\n    negative = number < 0 ? \"-\" : \"\",\n        base = parseInt(toFixed(Math.abs(number || 0), usePrecision), 10) + \"\",\n        mod = base.length > 3 ? base.length % 3 : 0; // Format the number:\n\n    return negative + (mod ? base.substr(0, mod) + opts.thousand : \"\") + base.substr(mod).replace(/(\\d{3})(?=\\d)/g, \"$1\" + opts.thousand) + (usePrecision ? opts.decimal + toFixed(Math.abs(number), usePrecision).split('.')[1] : \"\");\n  };\n  /**\n   * Format a number into currency\n   *\n   * Usage: accounting.formatMoney(number, symbol, precision, thousandsSep, decimalSep, format)\n   * defaults: (0, \"$\", 2, \",\", \".\", \"%s%v\")\n   *\n   * Localise by overriding the symbol, precision, thousand / decimal separators and format\n   * Second param can be an object matching `settings.currency` which is the easiest way.\n   *\n   * To do: tidy up the parameters\n   */\n\n\n  var formatMoney = lib.formatMoney = function (number, symbol, precision, thousand, decimal, format) {\n    // Resursively format arrays:\n    if (isArray(number)) {\n      return map(number, function (val) {\n        return formatMoney(val, symbol, precision, thousand, decimal, format);\n      });\n    } // Clean up number:\n\n\n    number = unformat(number); // Build options object from second param (if object) or all params, extending defaults:\n\n    var opts = defaults(isObject(symbol) ? symbol : {\n      symbol: symbol,\n      precision: precision,\n      thousand: thousand,\n      decimal: decimal,\n      format: format\n    }, lib.settings.currency),\n        // Check format (returns object with pos, neg and zero):\n    formats = checkCurrencyFormat(opts.format),\n        // Choose which format to use for this value:\n    useFormat = number > 0 ? formats.pos : number < 0 ? formats.neg : formats.zero; // Return with currency symbol added:\n\n    return useFormat.replace('%s', opts.symbol).replace('%v', formatNumber(Math.abs(number), checkPrecision(opts.precision), opts.thousand, opts.decimal));\n  };\n  /**\n   * Format a list of numbers into an accounting column, padding with whitespace\n   * to line up currency symbols, thousand separators and decimals places\n   *\n   * List should be an array of numbers\n   * Second parameter can be an object containing keys that match the params\n   *\n   * Returns array of accouting-formatted number strings of same length\n   *\n   * NB: `white-space:pre` CSS rule is required on the list container to prevent\n   * browsers from collapsing the whitespace in the output strings.\n   */\n\n\n  lib.formatColumn = function (list, symbol, precision, thousand, decimal, format) {\n    if (!list) return []; // Build options object from second param (if object) or all params, extending defaults:\n\n    var opts = defaults(isObject(symbol) ? symbol : {\n      symbol: symbol,\n      precision: precision,\n      thousand: thousand,\n      decimal: decimal,\n      format: format\n    }, lib.settings.currency),\n        // Check format (returns object with pos, neg and zero), only need pos for now:\n    formats = checkCurrencyFormat(opts.format),\n        // Whether to pad at start of string or after currency symbol:\n    padAfterSymbol = formats.pos.indexOf(\"%s\") < formats.pos.indexOf(\"%v\") ? true : false,\n        // Store value for the length of the longest string in the column:\n    maxLength = 0,\n        // Format the list according to options, store the length of the longest string:\n    formatted = map(list, function (val, i) {\n      if (isArray(val)) {\n        // Recursively format columns if list is a multi-dimensional array:\n        return lib.formatColumn(val, opts);\n      } else {\n        // Clean up the value\n        val = unformat(val); // Choose which format to use for this value (pos, neg or zero):\n\n        var useFormat = val > 0 ? formats.pos : val < 0 ? formats.neg : formats.zero,\n            // Format this value, push into formatted list and save the length:\n        fVal = useFormat.replace('%s', opts.symbol).replace('%v', formatNumber(Math.abs(val), checkPrecision(opts.precision), opts.thousand, opts.decimal));\n        if (fVal.length > maxLength) maxLength = fVal.length;\n        return fVal;\n      }\n    }); // Pad each number in the list and send back the column of numbers:\n\n    return map(formatted, function (val, i) {\n      // Only if this is a string (not a nested array, which would have already been padded):\n      if (isString(val) && val.length < maxLength) {\n        // Depending on symbol position, pad after symbol or at index 0:\n        return padAfterSymbol ? val.replace(opts.symbol, opts.symbol + new Array(maxLength - val.length + 1).join(\" \")) : new Array(maxLength - val.length + 1).join(\" \") + val;\n      }\n\n      return val;\n    });\n  };\n  /* --- Module Definition --- */\n  // Export accounting for CommonJS. If being loaded as an AMD module, define it as such.\n  // Otherwise, just add `accounting` to the global object\n\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = lib;\n    }\n\n    exports.accounting = lib;\n  } else if (typeof define === 'function' && define.amd) {\n    // Return the library as an AMD module:\n    define([], function () {\n      return lib;\n    });\n  } else {\n    // Use accounting.noConflict to restore `accounting` back to its original value.\n    // Returns a reference to the library's `accounting` object;\n    // e.g. `var numbers = accounting.noConflict();`\n    lib.noConflict = function (oldAccounting) {\n      return function () {\n        // Reset the value of the root's `accounting` variable:\n        root.accounting = oldAccounting; // Delete the noConflict method:\n\n        lib.noConflict = undefined; // Return reference to the library to re-assign it:\n\n        return lib;\n      };\n    }(root.accounting); // Declare `fx` on the root (global/window) object:\n\n\n    root['accounting'] = lib;\n  } // Root will be `window` in browser or `global` on the server:\n\n})(this);","map":{"version":3,"sources":["E:/Projects/hotfix_web/node_modules/accounting/accounting.js"],"names":["root","undefined","lib","version","settings","currency","symbol","format","decimal","thousand","precision","grouping","number","nativeMap","Array","prototype","map","nativeIsArray","isArray","toString","Object","isString","obj","charCodeAt","substr","call","isObject","defaults","object","defs","key","hasOwnProperty","iterator","context","results","i","j","length","checkPrecision","val","base","Math","round","abs","isNaN","checkCurrencyFormat","match","pos","neg","replace","zero","unformat","parse","value","regex","RegExp","unformatted","parseFloat","toFixed","power","pow","formatNumber","opts","usePrecision","negative","parseInt","mod","split","formatMoney","formats","useFormat","formatColumn","list","padAfterSymbol","indexOf","maxLength","formatted","fVal","join","exports","module","accounting","define","amd","noConflict","oldAccounting"],"mappings":"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","sourcesContent":["/*!\n * accounting.js v0.4.1\n * Copyright 2014 Open Exchange Rates\n *\n * Freely distributable under the MIT license.\n * Portions of accounting.js are inspired or borrowed from underscore.js\n *\n * Full details and documentation:\n * http://openexchangerates.github.io/accounting.js/\n */\n\n(function(root, undefined) {\n\n\t/* --- Setup --- */\n\n\t// Create the local library object, to be exported or referenced globally later\n\tvar lib = {};\n\n\t// Current version\n\tlib.version = '0.4.1';\n\n\n\t/* --- Exposed settings --- */\n\n\t// The library's settings configuration object. Contains default parameters for\n\t// currency and number formatting\n\tlib.settings = {\n\t\tcurrency: {\n\t\t\tsymbol : \"$\",\t\t// default currency symbol is '$'\n\t\t\tformat : \"%s%v\",\t// controls output: %s = symbol, %v = value (can be object, see docs)\n\t\t\tdecimal : \".\",\t\t// decimal point separator\n\t\t\tthousand : \",\",\t\t// thousands separator\n\t\t\tprecision : 2,\t\t// decimal places\n\t\t\tgrouping : 3\t\t// digit grouping (not implemented yet)\n\t\t},\n\t\tnumber: {\n\t\t\tprecision : 0,\t\t// default precision on numbers is 0\n\t\t\tgrouping : 3,\t\t// digit grouping (not implemented yet)\n\t\t\tthousand : \",\",\n\t\t\tdecimal : \".\"\n\t\t}\n\t};\n\n\n\t/* --- Internal Helper Methods --- */\n\n\t// Store reference to possibly-available ECMAScript 5 methods for later\n\tvar nativeMap = Array.prototype.map,\n\t\tnativeIsArray = Array.isArray,\n\t\ttoString = Object.prototype.toString;\n\n\t/**\n\t * Tests whether supplied parameter is a string\n\t * from underscore.js\n\t */\n\tfunction isString(obj) {\n\t\treturn !!(obj === '' || (obj && obj.charCodeAt && obj.substr));\n\t}\n\n\t/**\n\t * Tests whether supplied parameter is a string\n\t * from underscore.js, delegates to ECMA5's native Array.isArray\n\t */\n\tfunction isArray(obj) {\n\t\treturn nativeIsArray ? nativeIsArray(obj) : toString.call(obj) === '[object Array]';\n\t}\n\n\t/**\n\t * Tests whether supplied parameter is a true object\n\t */\n\tfunction isObject(obj) {\n\t\treturn obj && toString.call(obj) === '[object Object]';\n\t}\n\n\t/**\n\t * Extends an object with a defaults object, similar to underscore's _.defaults\n\t *\n\t * Used for abstracting parameter handling from API methods\n\t */\n\tfunction defaults(object, defs) {\n\t\tvar key;\n\t\tobject = object || {};\n\t\tdefs = defs || {};\n\t\t// Iterate over object non-prototype properties:\n\t\tfor (key in defs) {\n\t\t\tif (defs.hasOwnProperty(key)) {\n\t\t\t\t// Replace values with defaults only if undefined (allow empty/zero values):\n\t\t\t\tif (object[key] == null) object[key] = defs[key];\n\t\t\t}\n\t\t}\n\t\treturn object;\n\t}\n\n\t/**\n\t * Implementation of `Array.map()` for iteration loops\n\t *\n\t * Returns a new Array as a result of calling `iterator` on each array value.\n\t * Defers to native Array.map if available\n\t */\n\tfunction map(obj, iterator, context) {\n\t\tvar results = [], i, j;\n\n\t\tif (!obj) return results;\n\n\t\t// Use native .map method if it exists:\n\t\tif (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n\n\t\t// Fallback for native .map:\n\t\tfor (i = 0, j = obj.length; i < j; i++ ) {\n\t\t\tresults[i] = iterator.call(context, obj[i], i, obj);\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * Check and normalise the value of precision (must be positive integer)\n\t */\n\tfunction checkPrecision(val, base) {\n\t\tval = Math.round(Math.abs(val));\n\t\treturn isNaN(val)? base : val;\n\t}\n\n\n\t/**\n\t * Parses a format string or object and returns format obj for use in rendering\n\t *\n\t * `format` is either a string with the default (positive) format, or object\n\t * containing `pos` (required), `neg` and `zero` values (or a function returning\n\t * either a string or object)\n\t *\n\t * Either string or format.pos must contain \"%v\" (value) to be valid\n\t */\n\tfunction checkCurrencyFormat(format) {\n\t\tvar defaults = lib.settings.currency.format;\n\n\t\t// Allow function as format parameter (should return string or object):\n\t\tif ( typeof format === \"function\" ) format = format();\n\n\t\t// Format can be a string, in which case `value` (\"%v\") must be present:\n\t\tif ( isString( format ) && format.match(\"%v\") ) {\n\n\t\t\t// Create and return positive, negative and zero formats:\n\t\t\treturn {\n\t\t\t\tpos : format,\n\t\t\t\tneg : format.replace(\"-\", \"\").replace(\"%v\", \"-%v\"),\n\t\t\t\tzero : format\n\t\t\t};\n\n\t\t// If no format, or object is missing valid positive value, use defaults:\n\t\t} else if ( !format || !format.pos || !format.pos.match(\"%v\") ) {\n\n\t\t\t// If defaults is a string, casts it to an object for faster checking next time:\n\t\t\treturn ( !isString( defaults ) ) ? defaults : lib.settings.currency.format = {\n\t\t\t\tpos : defaults,\n\t\t\t\tneg : defaults.replace(\"%v\", \"-%v\"),\n\t\t\t\tzero : defaults\n\t\t\t};\n\n\t\t}\n\t\t// Otherwise, assume format was fine:\n\t\treturn format;\n\t}\n\n\n\t/* --- API Methods --- */\n\n\t/**\n\t * Takes a string/array of strings, removes all formatting/cruft and returns the raw float value\n\t * Alias: `accounting.parse(string)`\n\t *\n\t * Decimal must be included in the regular expression to match floats (defaults to\n\t * accounting.settings.number.decimal), so if the number uses a non-standard decimal \n\t * separator, provide it as the second argument.\n\t *\n\t * Also matches bracketed negatives (eg. \"$ (1.99)\" => -1.99)\n\t *\n\t * Doesn't throw any errors (`NaN`s become 0) but this may change in future\n\t */\n\tvar unformat = lib.unformat = lib.parse = function(value, decimal) {\n\t\t// Recursively unformat arrays:\n\t\tif (isArray(value)) {\n\t\t\treturn map(value, function(val) {\n\t\t\t\treturn unformat(val, decimal);\n\t\t\t});\n\t\t}\n\n\t\t// Fails silently (need decent errors):\n\t\tvalue = value || 0;\n\n\t\t// Return the value as-is if it's already a number:\n\t\tif (typeof value === \"number\") return value;\n\n\t\t// Default decimal point comes from settings, but could be set to eg. \",\" in opts:\n\t\tdecimal = decimal || lib.settings.number.decimal;\n\n\t\t // Build regex to strip out everything except digits, decimal point and minus sign:\n\t\tvar regex = new RegExp(\"[^0-9-\" + decimal + \"]\", [\"g\"]),\n\t\t\tunformatted = parseFloat(\n\t\t\t\t(\"\" + value)\n\t\t\t\t.replace(/\\((.*)\\)/, \"-$1\") // replace bracketed values with negatives\n\t\t\t\t.replace(regex, '')         // strip out any cruft\n\t\t\t\t.replace(decimal, '.')      // make sure decimal point is standard\n\t\t\t);\n\n\t\t// This will fail silently which may cause trouble, let's wait and see:\n\t\treturn !isNaN(unformatted) ? unformatted : 0;\n\t};\n\n\n\t/**\n\t * Implementation of toFixed() that treats floats more like decimals\n\t *\n\t * Fixes binary rounding issues (eg. (0.615).toFixed(2) === \"0.61\") that present\n\t * problems for accounting- and finance-related software.\n\t */\n\tvar toFixed = lib.toFixed = function(value, precision) {\n\t\tprecision = checkPrecision(precision, lib.settings.number.precision);\n\t\tvar power = Math.pow(10, precision);\n\n\t\t// Multiply up by precision, round accurately, then divide and use native toFixed():\n\t\treturn (Math.round(lib.unformat(value) * power) / power).toFixed(precision);\n\t};\n\n\n\t/**\n\t * Format a number, with comma-separated thousands and custom precision/decimal places\n\t * Alias: `accounting.format()`\n\t *\n\t * Localise by overriding the precision and thousand / decimal separators\n\t * 2nd parameter `precision` can be an object matching `settings.number`\n\t */\n\tvar formatNumber = lib.formatNumber = lib.format = function(number, precision, thousand, decimal) {\n\t\t// Resursively format arrays:\n\t\tif (isArray(number)) {\n\t\t\treturn map(number, function(val) {\n\t\t\t\treturn formatNumber(val, precision, thousand, decimal);\n\t\t\t});\n\t\t}\n\n\t\t// Clean up number:\n\t\tnumber = unformat(number);\n\n\t\t// Build options object from second param (if object) or all params, extending defaults:\n\t\tvar opts = defaults(\n\t\t\t\t(isObject(precision) ? precision : {\n\t\t\t\t\tprecision : precision,\n\t\t\t\t\tthousand : thousand,\n\t\t\t\t\tdecimal : decimal\n\t\t\t\t}),\n\t\t\t\tlib.settings.number\n\t\t\t),\n\n\t\t\t// Clean up precision\n\t\t\tusePrecision = checkPrecision(opts.precision),\n\n\t\t\t// Do some calc:\n\t\t\tnegative = number < 0 ? \"-\" : \"\",\n\t\t\tbase = parseInt(toFixed(Math.abs(number || 0), usePrecision), 10) + \"\",\n\t\t\tmod = base.length > 3 ? base.length % 3 : 0;\n\n\t\t// Format the number:\n\t\treturn negative + (mod ? base.substr(0, mod) + opts.thousand : \"\") + base.substr(mod).replace(/(\\d{3})(?=\\d)/g, \"$1\" + opts.thousand) + (usePrecision ? opts.decimal + toFixed(Math.abs(number), usePrecision).split('.')[1] : \"\");\n\t};\n\n\n\t/**\n\t * Format a number into currency\n\t *\n\t * Usage: accounting.formatMoney(number, symbol, precision, thousandsSep, decimalSep, format)\n\t * defaults: (0, \"$\", 2, \",\", \".\", \"%s%v\")\n\t *\n\t * Localise by overriding the symbol, precision, thousand / decimal separators and format\n\t * Second param can be an object matching `settings.currency` which is the easiest way.\n\t *\n\t * To do: tidy up the parameters\n\t */\n\tvar formatMoney = lib.formatMoney = function(number, symbol, precision, thousand, decimal, format) {\n\t\t// Resursively format arrays:\n\t\tif (isArray(number)) {\n\t\t\treturn map(number, function(val){\n\t\t\t\treturn formatMoney(val, symbol, precision, thousand, decimal, format);\n\t\t\t});\n\t\t}\n\n\t\t// Clean up number:\n\t\tnumber = unformat(number);\n\n\t\t// Build options object from second param (if object) or all params, extending defaults:\n\t\tvar opts = defaults(\n\t\t\t\t(isObject(symbol) ? symbol : {\n\t\t\t\t\tsymbol : symbol,\n\t\t\t\t\tprecision : precision,\n\t\t\t\t\tthousand : thousand,\n\t\t\t\t\tdecimal : decimal,\n\t\t\t\t\tformat : format\n\t\t\t\t}),\n\t\t\t\tlib.settings.currency\n\t\t\t),\n\n\t\t\t// Check format (returns object with pos, neg and zero):\n\t\t\tformats = checkCurrencyFormat(opts.format),\n\n\t\t\t// Choose which format to use for this value:\n\t\t\tuseFormat = number > 0 ? formats.pos : number < 0 ? formats.neg : formats.zero;\n\n\t\t// Return with currency symbol added:\n\t\treturn useFormat.replace('%s', opts.symbol).replace('%v', formatNumber(Math.abs(number), checkPrecision(opts.precision), opts.thousand, opts.decimal));\n\t};\n\n\n\t/**\n\t * Format a list of numbers into an accounting column, padding with whitespace\n\t * to line up currency symbols, thousand separators and decimals places\n\t *\n\t * List should be an array of numbers\n\t * Second parameter can be an object containing keys that match the params\n\t *\n\t * Returns array of accouting-formatted number strings of same length\n\t *\n\t * NB: `white-space:pre` CSS rule is required on the list container to prevent\n\t * browsers from collapsing the whitespace in the output strings.\n\t */\n\tlib.formatColumn = function(list, symbol, precision, thousand, decimal, format) {\n\t\tif (!list) return [];\n\n\t\t// Build options object from second param (if object) or all params, extending defaults:\n\t\tvar opts = defaults(\n\t\t\t\t(isObject(symbol) ? symbol : {\n\t\t\t\t\tsymbol : symbol,\n\t\t\t\t\tprecision : precision,\n\t\t\t\t\tthousand : thousand,\n\t\t\t\t\tdecimal : decimal,\n\t\t\t\t\tformat : format\n\t\t\t\t}),\n\t\t\t\tlib.settings.currency\n\t\t\t),\n\n\t\t\t// Check format (returns object with pos, neg and zero), only need pos for now:\n\t\t\tformats = checkCurrencyFormat(opts.format),\n\n\t\t\t// Whether to pad at start of string or after currency symbol:\n\t\t\tpadAfterSymbol = formats.pos.indexOf(\"%s\") < formats.pos.indexOf(\"%v\") ? true : false,\n\n\t\t\t// Store value for the length of the longest string in the column:\n\t\t\tmaxLength = 0,\n\n\t\t\t// Format the list according to options, store the length of the longest string:\n\t\t\tformatted = map(list, function(val, i) {\n\t\t\t\tif (isArray(val)) {\n\t\t\t\t\t// Recursively format columns if list is a multi-dimensional array:\n\t\t\t\t\treturn lib.formatColumn(val, opts);\n\t\t\t\t} else {\n\t\t\t\t\t// Clean up the value\n\t\t\t\t\tval = unformat(val);\n\n\t\t\t\t\t// Choose which format to use for this value (pos, neg or zero):\n\t\t\t\t\tvar useFormat = val > 0 ? formats.pos : val < 0 ? formats.neg : formats.zero,\n\n\t\t\t\t\t\t// Format this value, push into formatted list and save the length:\n\t\t\t\t\t\tfVal = useFormat.replace('%s', opts.symbol).replace('%v', formatNumber(Math.abs(val), checkPrecision(opts.precision), opts.thousand, opts.decimal));\n\n\t\t\t\t\tif (fVal.length > maxLength) maxLength = fVal.length;\n\t\t\t\t\treturn fVal;\n\t\t\t\t}\n\t\t\t});\n\n\t\t// Pad each number in the list and send back the column of numbers:\n\t\treturn map(formatted, function(val, i) {\n\t\t\t// Only if this is a string (not a nested array, which would have already been padded):\n\t\t\tif (isString(val) && val.length < maxLength) {\n\t\t\t\t// Depending on symbol position, pad after symbol or at index 0:\n\t\t\t\treturn padAfterSymbol ? val.replace(opts.symbol, opts.symbol+(new Array(maxLength - val.length + 1).join(\" \"))) : (new Array(maxLength - val.length + 1).join(\" \")) + val;\n\t\t\t}\n\t\t\treturn val;\n\t\t});\n\t};\n\n\n\t/* --- Module Definition --- */\n\n\t// Export accounting for CommonJS. If being loaded as an AMD module, define it as such.\n\t// Otherwise, just add `accounting` to the global object\n\tif (typeof exports !== 'undefined') {\n\t\tif (typeof module !== 'undefined' && module.exports) {\n\t\t\texports = module.exports = lib;\n\t\t}\n\t\texports.accounting = lib;\n\t} else if (typeof define === 'function' && define.amd) {\n\t\t// Return the library as an AMD module:\n\t\tdefine([], function() {\n\t\t\treturn lib;\n\t\t});\n\t} else {\n\t\t// Use accounting.noConflict to restore `accounting` back to its original value.\n\t\t// Returns a reference to the library's `accounting` object;\n\t\t// e.g. `var numbers = accounting.noConflict();`\n\t\tlib.noConflict = (function(oldAccounting) {\n\t\t\treturn function() {\n\t\t\t\t// Reset the value of the root's `accounting` variable:\n\t\t\t\troot.accounting = oldAccounting;\n\t\t\t\t// Delete the noConflict method:\n\t\t\t\tlib.noConflict = undefined;\n\t\t\t\t// Return reference to the library to re-assign it:\n\t\t\t\treturn lib;\n\t\t\t};\n\t\t})(root.accounting);\n\n\t\t// Declare `fx` on the root (global/window) object:\n\t\troot['accounting'] = lib;\n\t}\n\n\t// Root will be `window` in browser or `global` on the server:\n}(this));\n"]},"metadata":{},"sourceType":"script"}